// Copyright (c) 2015-2016 K Team. All Rights Reserved.
package org.kframework.kore;

import com.beust.jcommander.internal.Lists;
import dk.brics.automaton.Automaton;
import dk.brics.automaton.RegExp;
import dk.brics.automaton.RunAutomaton;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.kframework.attributes.Source;
import org.kframework.definition.Definition;
import org.kframework.definition.Module;
import org.kframework.definition.RegexTerminal;
import org.kframework.frontend.convertors.KILtoKORE;
import org.kframework.parser.concrete2kore.ParseInModule;
import org.kframework.parser.concrete2kore.ParserUtils;
import org.kframework.parser.concrete2kore.generator.RuleGrammarGenerator;
import org.kframework.treeNodes.Term;
import org.kframework.utils.FileUtil;
import org.kframework.utils.GlobalOptions;
import org.kframework.utils.errorsystem.KExceptionManager;
import org.kframework.utils.errorsystem.ParseFailedException;
import scala.Tuple2;
import scala.util.Either;

import java.util.Set;

import static org.kframework.definition.Constructors.Sort;

public class ConvertToKoreTest {

    ParserUtils defParser;

    @Before
    public void setUp() throws Exception {
        defParser = new ParserUtils(FileUtil.testFileUtil()::resolveWorkingDirectory, new KExceptionManager(new GlobalOptions()));
    }

    private void parseProgram(String input, String def, String startSymbol, int warnings, boolean expectedError) {
        Definition baseK = defParser.loadDefinition("TEST", "TEST", def, new Source("RuleGrammarTest"), Lists.newArrayList());
        Module test = baseK.getModule("TEST").get();
        ParseInModule parser = RuleGrammarGenerator.getCombinedGrammar(RuleGrammarGenerator.getProgramsGrammar(test, baseK));
        Tuple2<Either<Set<ParseFailedException>, Term>, Set<ParseFailedException>> rule = parser.parseStringKeepAmb(input, Sort(startSymbol), Source.apply("generated by RuleGrammarTest"));
        printout(rule, warnings, expectedError);
    }

    private void printout(Tuple2<Either<Set<ParseFailedException>, Term>, Set<ParseFailedException>> rule, int warnings, boolean expectedError) {
        if (false) { // true to print detailed results
            KExceptionManager kem = new KExceptionManager(new GlobalOptions(true, GlobalOptions.Warnings.ALL, true));
            if (rule._1().isLeft()) {
                for (ParseFailedException x : rule._1().left().get()) {
                    kem.addKException(x.getKException());
                }
            } else {
                System.err.println("rule = " + rule._1().right().get());
            }
            for (ParseFailedException x : rule._2()) {
                kem.addKException(x.getKException());
            }
            kem.print();
        }
        if (expectedError)
            Assert.assertTrue("Expected error here: ", rule._1().isLeft());
        else {
            Assert.assertTrue("Expected no errors here: ", rule._1().isRight());
            //ConvertToKoreVisitor conv = new ConvertToKoreVisitor();
            //conv.apply(rule._1.right().get());
            //System.out.println(conv.sb.toString());
            System.out.println(TreeNodesToKORE.apply(rule._1.right().get()));
        }
        Assert.assertEquals("Expected " + warnings + " warnings: ", warnings, rule._2().size());

    }

    // test simple Nat
    @Test
    public void test01() {
        String def = "" +
                "module TEST \n" +
                " syntax Nat ::= r\"[0-9]+\" [token] \n" +
                "endmodule \n";
        parseProgram("1", def, "Nat", 0, false);
        parseProgram("20", def, "Nat", 0, false);
    }

    // test simple Int operation
    @Test
    public void test02() {
        String def = "" +
                "module TEST \n" +
                " syntax Int ::= r\"[0-9]+\" [token] \n" +
                " syntax Int ::= Int \"+\" Int [klabel(plus)] \n" +
                "endmodule \n";
        parseProgram("1", def, "Int", 0, false);
        parseProgram("1+20", def, "Int", 0, false);
        parseProgram("1+2+3", def, "Int", 0, false);
    }

    // test simple injections
    @Test
    public void test03() {
        String def = "" +
                "module TEST \n" +
                " syntax Int ::= r\"[0-9]+\" [token] \n" +
                " syntax Exp ::= Exp \"+\" Exp [klabel(plus)] \n" +
                " syntax Exp ::= Int [klabel(inj)] \n" +
                "endmodule \n";
        parseProgram("1", def, "Int", 0, false);
        parseProgram("1", def, "Exp", 0, false);
        parseProgram("1+2", def, "Exp", 0, false);
        parseProgram("1+2+3", def, "Exp", 0, false);
    }
}
